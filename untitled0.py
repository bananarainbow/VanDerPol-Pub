# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18JzZZC6ybZQLLn2vW0jl5zK9XDk63g0i
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

# Van der Pol oscillator definition
def van_der_pol(t, x, mu=1.0):
    x1, x2 = x
    dx1dt = x2
    dx2dt = mu * (1 - x1**2) * x2 - x1
    return [dx1dt, dx2dt]

# Parameters and initial conditions
mu = 1.0
x0 = [2, 0]
t_span = (0, 40)
t_eval = np.linspace(*t_span, 1000)

# Solve ODE
sol = solve_ivp(van_der_pol, t_span, x0, args=(mu,), t_eval=t_eval)

# Plot state trajectory
plt.figure(figsize=(12, 5))

# x1 and x2 vs time
plt.subplot(1, 2, 1)
plt.plot(sol.t, sol.y[0], label='x1(t)')
plt.plot(sol.t, sol.y[1], label='x2(t)')
plt.xlabel('Time t')
plt.ylabel('States')
plt.title('State Trajectories')
plt.legend()

# Phase portrait
plt.subplot(1, 2, 2)
plt.plot(sol.y[0], sol.y[1])
plt.xlabel('x1')
plt.ylabel('x2')
plt.title('Phase Portrait (Limit Cycle)')

plt.tight_layout()
plt.show()



import numpy as np

# Define noise parameters
sigma = 0.05
num_samples = 200

# Sample times ti from interval [10, 40]
t_samples = np.linspace(10, 40, num_samples)

# Interpolate the ODE solution to get x1(ti), x2(ti)
from scipy.interpolate import interp1d

x1_interp = interp1d(sol.t, sol.y[0], kind='cubic')
x2_interp = interp1d(sol.t, sol.y[1], kind='cubic')

x1_clean = x1_interp(t_samples)
x2_clean = x2_interp(t_samples)

# Add Gaussian noise
noise_x1 = np.random.normal(0, sigma, num_samples)
noise_x2 = np.random.normal(0, sigma, num_samples)

x1_noisy = x1_clean + noise_x1
x2_noisy = x2_clean + noise_x2

# Result: (x1_noisy, x2_noisy) are the noisy measurements
type(x1_noisy)

K = 25
b = np.array([x1_noisy[K:], x2_noisy[K:]]).T

# Interleave x1, x2
X = np.array([item for pair in zip(x1_noisy, x2_noisy) for item in pair])

# Build design matrix A
A = [X[:2*K]]
for i in range(1, 200 - K):
    A.append(X[2*i:2*K + 2*i])
A = np.array(A)

# Solve for LAM using pseudo-inverse for stability
LAM = np.linalg.pinv(A) @ b

# Initialize prediction
sol_x1 = list(x1_noisy[:K])
sol_x2 = list(x2_noisy[:K])
input = np.array([item for pair in zip(sol_x1, sol_x2) for item in pair])

# Prediction loop
for i in range(200-K):
    x_new = input @ LAM
    sol_x1.append(x_new[0])
    sol_x2.append(x_new[1])
    input = np.append(input, x_new)
    input = np.delete(input, [0, 1])  # Remove oldest x1,x2 pair

# Convert results to NumPy arrays
sol_x1 = np.array(sol_x1)
sol_x2 = np.array(sol_x2)

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 5))

# Plot sol_x1
plt.plot(sol_x1, label='sol_x1', color='blue')

# Plot sol_x2
plt.plot(sol_x2, label='sol_x2', color='orange')

plt.plot(x1_noisy, '--', label='x1_noisy', color='blue', alpha=0.3)
plt.plot(x2_noisy, '--', label='x2_noisy', color='orange', alpha=0.3)


# Labels and legend
plt.title('Predicted Signals: sol_x1 and sol_x2')
plt.xlabel('Time Step')
plt.ylabel('Value')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(6, 6))
plt.plot(x1_noisy, x2_noisy, '--', label='Noisy', alpha=0.3)
plt.plot(sol_x1, sol_x2, color='purple', label='Predicted trajectory')
plt.xlabel('sol_x1')
plt.ylabel('sol_x2')
plt.title('2D Phase Plot: sol_x1 vs sol_x2')
plt.grid(True)
plt.legend()
plt.axis('equal')  # Keeps aspect ratio square
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import solve_continuous_are

# Define system matrices
A = np.array([[0, 1],
              [-1, 1]])
B = np.array([[0],
              [1]])

Q = np.array([[1, 0],
              [0, 1]])
R = np.array([[1]])

# Solve Continuous Algebraic Riccati Equation
P = solve_continuous_are(A, B, Q, R)
K = np.linalg.inv(R) @ B.T @ P

# Create a reference trajectory
T = 40
dt = 0.2
time = np.arange(0, T, dt)

x_d = np.vstack((x1_noisy, x2_noisy))  # shape: (2, N)

# Compute time derivative of x_d (approximation)
Dx_d = np.gradient(x_d, dt, axis=1)  # shape: (2, N)

# Compute feedforward input: u_d = B^T (Dx_d - A x_d)
u_d = np.zeros(len(time))
for i in range(len(time)):
    xd = x_d[:, i].reshape(-1, 1)
    dxd = Dx_d[:, i].reshape(-1, 1)
    u_d[i] = (B.T @ (dxd - A @ xd)).item()

# Simulate system
x = np.array([[2.0], [0.0]])  # initial state
x_simulate = []

for i in range(len(time)):
    xd = x_d[:, i].reshape(-1, 1)
    ud = u_d[i]
    u = ud - K @ (x - xd)
    x_dot = A @ x + B @ u
    x += x_dot * dt
    x_simulate.append(x.flatten())

x_simulate = np.array(x_simulate)

# --- Plotting with 3 subplots ---
plt.figure(figsize=(10, 8))

# x1 plot
plt.subplot(3, 1, 1)
plt.plot(time, x_simulate[:, 0], label='x1(t)', linewidth=2)
plt.plot(time, x_d[0, :], '--', label='x1_d(t)', linewidth=2)
plt.ylabel("x1")
plt.legend()
plt.grid(True)
plt.title("Tracking LQR - Subplots")

# x2 plot
plt.subplot(3, 1, 2)
plt.plot(time, x_simulate[:, 1], label='x2(t)', linewidth=2)
plt.plot(time, x_d[1, :], '--', label='x2_d(t)', linewidth=2)
plt.ylabel("x2")
plt.legend()
plt.grid(True)

# Tracking error plot
plt.subplot(3, 1, 3)
plt.plot(time, x_d[0, :] - x_simulate[:, 0], label='e1(t)', linewidth=2)
plt.plot(time, x_d[1, :] - x_simulate[:, 1], '--', label='e2(t)', linewidth=2)
plt.xlabel("Time [s]")
plt.ylabel("Tracking Error")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

plt.figure(figsize=(6, 6))
plt.plot(x1_noisy, x2_noisy, '--', label='Noisy', alpha=0.3)
plt.plot(x_simulate[:, 0], x_simulate[:, 1], color='purple', label='Predicted trajectory')
plt.xlabel('sol_x1')
plt.ylabel('sol_x2')
plt.title('2D Phase Plot: sol_x1 vs sol_x2')
plt.grid(True)
plt.legend()
plt.axis('equal')  # Keeps aspect ratio square
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import solve_continuous_are

# Define system matrices
A = np.array([[0, 1],
              [-1, 1]])
B = np.array([[0],
              [1]])

Q = np.array([[10, 0],
              [0, 10]])
R = np.array([[1]])

# Solve Continuous Algebraic Riccati Equation
P = solve_continuous_are(A, B, Q, R)
K = np.linalg.inv(R) @ B.T @ P

# Create a reference trajectory
T = 40
dt = 0.2
time = np.arange(0, T, dt)

x_d = np.vstack((x1_noisy, x2_noisy))  # shape: (2, N)

# Compute time derivative of x_d (approximation)
Dx_d = np.gradient(x_d, dt, axis=1)  # shape: (2, N)

# Compute feedforward input: u_d = B^T (Dx_d - A x_d)
u_d = np.zeros(len(time))
for i in range(len(time)):
    xd = x_d[:, i].reshape(-1, 1)
    dxd = Dx_d[:, i].reshape(-1, 1)
    u_d[i] = (B.T @ (dxd - A @ xd)).item()

# Simulate system
x = np.array([[2.0], [0.0]])  # initial state
x_simulate = []

for i in range(len(time)):
    xd = x_d[:, i].reshape(-1, 1)
    ud = u_d[i]
    u = ud - K @ (x - xd)
    x_dot = A @ x + B @ u
    x += x_dot * dt
    x_simulate.append(x.flatten())

x_simulate = np.array(x_simulate)

# --- Plotting with 3 subplots ---
plt.figure(figsize=(10, 8))

# x1 plot
plt.subplot(3, 1, 1)
plt.plot(time, x_simulate[:, 0], label='x1(t)', linewidth=2)
plt.plot(time, x_d[0, :], '--', label='x1_d(t)', linewidth=2)
plt.ylabel("x1")
plt.legend()
plt.grid(True)
plt.title("Tracking LQR - Subplots")

# x2 plot
plt.subplot(3, 1, 2)
plt.plot(time, x_simulate[:, 1], label='x2(t)', linewidth=2)
plt.plot(time, x_d[1, :], '--', label='x2_d(t)', linewidth=2)
plt.ylabel("x2")
plt.legend()
plt.grid(True)

# Tracking error plot
plt.subplot(3, 1, 3)
plt.plot(time, x_d[0, :] - x_simulate[:, 0], label='e1(t)', linewidth=2)
plt.plot(time, x_d[1, :] - x_simulate[:, 1], '--', label='e2(t)', linewidth=2)
plt.xlabel("Time [s]")
plt.ylabel("Tracking Error")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

plt.figure(figsize=(6, 6))
plt.plot(x1_noisy, x2_noisy, '--', label='Noisy', alpha=0.3)
plt.plot(x_simulate[:, 0], x_simulate[:, 1], color='purple', label='Predicted trajectory')
plt.xlabel('sol_x1')
plt.ylabel('sol_x2')
plt.title('2D Phase Plot: sol_x1 vs sol_x2')
plt.grid(True)
plt.legend()
plt.axis('equal')  # Keeps aspect ratio square
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import solve_continuous_are

# Define system matrices
A = np.array([[0, 1],
              [-1, 1]])
B = np.array([[0],
              [1]])

Q = np.array([[100, 0],
              [0, 100]])
R = np.array([[1]])

# Solve Continuous Algebraic Riccati Equation
P = solve_continuous_are(A, B, Q, R)
K = np.linalg.inv(R) @ B.T @ P

# Create a reference trajectory
T = 40
dt = 0.2
time = np.arange(0, T, dt)

x_d = np.vstack((x1_noisy, x2_noisy))  # shape: (2, N)

# Compute time derivative of x_d (approximation)
Dx_d = np.gradient(x_d, dt, axis=1)  # shape: (2, N)

# Compute feedforward input: u_d = B^T (Dx_d - A x_d)
u_d = np.zeros(len(time))
for i in range(len(time)):
    xd = x_d[:, i].reshape(-1, 1)
    dxd = Dx_d[:, i].reshape(-1, 1)
    u_d[i] = (B.T @ (dxd - A @ xd)).item()

# Simulate system
x = np.array([[2.0], [0.0]])  # initial state
x_simulate = []

for i in range(len(time)):
    xd = x_d[:, i].reshape(-1, 1)
    ud = u_d[i]
    u = ud - K @ (x - xd)
    x_dot = A @ x + B @ u
    x += x_dot * dt
    x_simulate.append(x.flatten())

x_simulate = np.array(x_simulate)

# --- Plotting with 3 subplots ---
plt.figure(figsize=(10, 8))

# x1 plot
plt.subplot(3, 1, 1)
plt.plot(time, x_simulate[:, 0], label='x1(t)', linewidth=2)
plt.plot(time, x_d[0, :], '--', label='x1_d(t)', linewidth=2)
plt.ylabel("x1")
plt.legend()
plt.grid(True)
plt.title("Tracking LQR - Subplots")

# x2 plot
plt.subplot(3, 1, 2)
plt.plot(time, x_simulate[:, 1], label='x2(t)', linewidth=2)
plt.plot(time, x_d[1, :], '--', label='x2_d(t)', linewidth=2)
plt.ylabel("x2")
plt.legend()
plt.grid(True)

# Tracking error plot
plt.subplot(3, 1, 3)
plt.plot(time, x_d[0, :] - x_simulate[:, 0], label='e1(t)', linewidth=2)
plt.plot(time, x_d[1, :] - x_simulate[:, 1], '--', label='e2(t)', linewidth=2)
plt.xlabel("Time [s]")
plt.ylabel("Tracking Error")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

plt.figure(figsize=(6, 6))
plt.plot(x1_noisy, x2_noisy, '--', label='Noisy', alpha=0.3)
plt.plot(x_simulate[:, 0], x_simulate[:, 1], color='purple', label='Predicted trajectory')
plt.xlabel('sol_x1')
plt.ylabel('sol_x2')
plt.title('2D Phase Plot: sol_x1 vs sol_x2')
plt.grid(True)
plt.legend()
plt.axis('equal')  # Keeps aspect ratio square
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import solve_continuous_are

# Define system matrices
A = np.array([[0, 1],
              [-1, 1]])
B = np.array([[0],
              [1]])

Q = np.array([[1, 0],
              [0, 1]])
R = np.array([[1]])

# Solve Continuous Algebraic Riccati Equation
P = solve_continuous_are(A, B, Q, R)
K = np.linalg.inv(R) @ B.T @ P

# Create a reference trajectory
T = 40
dt = 0.2
time = np.arange(0, T, dt)

x_d = np.vstack((x1_noisy, x2_noisy))  # shape: (2, N)

# Compute time derivative of x_d (approximation)
Dx_d = np.gradient(x_d, dt, axis=1)  # shape: (2, N)

# Compute feedforward input: u_d = B^T (Dx_d - A x_d)
u_d = np.zeros(len(time))
for i in range(len(time)):
    xd = x_d[:, i].reshape(-1, 1)
    dxd = Dx_d[:, i].reshape(-1, 1)
    u_d[i] = (B.T @ (dxd - A @ xd)).item()

# Simulate system
x = np.array([[-1.0], [-1.0]])  # initial state
x_simulate = []

for i in range(len(time)):
    xd = x_d[:, i].reshape(-1, 1)
    ud = u_d[i]
    u = ud - K @ (x - xd)
    x_dot = A @ x + B @ u
    x += x_dot * dt
    x_simulate.append(x.flatten())

x_simulate = np.array(x_simulate)

# --- Plotting with 3 subplots ---
plt.figure(figsize=(10, 8))

# x1 plot
plt.subplot(3, 1, 1)
plt.plot(time, x_simulate[:, 0], label='x1(t)', linewidth=2)
plt.plot(time, x_d[0, :], '--', label='x1_d(t)', linewidth=2)
plt.ylabel("x1")
plt.legend()
plt.grid(True)
plt.title("Tracking LQR - Subplots")

# x2 plot
plt.subplot(3, 1, 2)
plt.plot(time, x_simulate[:, 1], label='x2(t)', linewidth=2)
plt.plot(time, x_d[1, :], '--', label='x2_d(t)', linewidth=2)
plt.ylabel("x2")
plt.legend()
plt.grid(True)

# Tracking error plot
plt.subplot(3, 1, 3)
plt.plot(time, x_d[0, :] - x_simulate[:, 0], label='e1(t)', linewidth=2)
plt.plot(time, x_d[1, :] - x_simulate[:, 1], '--', label='e2(t)', linewidth=2)
plt.xlabel("Time [s]")
plt.ylabel("Tracking Error")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

plt.figure(figsize=(6, 6))
plt.plot(x1_noisy, x2_noisy, '--', label='Noisy', alpha=0.3)
plt.plot(x_simulate[:, 0], x_simulate[:, 1], color='purple', label='Predicted trajectory')
plt.xlabel('sol_x1')
plt.ylabel('sol_x2')
plt.title('2D Phase Plot: sol_x1 vs sol_x2')
plt.grid(True)
plt.legend()
plt.axis('equal')  # Keeps aspect ratio square
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import solve_continuous_are

# Define system matrices
A = np.array([[0, 1],
              [-1, 1]])
B = np.array([[0],
              [1]])

Q = np.array([[10, 0],
              [0, 10]])
R = np.array([[1]])

# Solve Continuous Algebraic Riccati Equation
P = solve_continuous_are(A, B, Q, R)
K = np.linalg.inv(R) @ B.T @ P

# Create a reference trajectory
T = 40
dt = 0.2
time = np.arange(0, T, dt)

x_d = np.vstack((x1_noisy, x2_noisy))  # shape: (2, N)

# Compute time derivative of x_d (approximation)
Dx_d = np.gradient(x_d, dt, axis=1)  # shape: (2, N)

# Compute feedforward input: u_d = B^T (Dx_d - A x_d)
u_d = np.zeros(len(time))
for i in range(len(time)):
    xd = x_d[:, i].reshape(-1, 1)
    dxd = Dx_d[:, i].reshape(-1, 1)
    u_d[i] = (B.T @ (dxd - A @ xd)).item()

# Simulate system
x = np.array([[-1.0], [-1.0]])  # initial state
x_simulate = []

for i in range(len(time)):
    xd = x_d[:, i].reshape(-1, 1)
    ud = u_d[i]
    u = ud - K @ (x - xd)
    x_dot = A @ x + B @ u
    x += x_dot * dt
    x_simulate.append(x.flatten())

x_simulate = np.array(x_simulate)

# --- Plotting with 3 subplots ---
plt.figure(figsize=(10, 8))

# x1 plot
plt.subplot(3, 1, 1)
plt.plot(time, x_simulate[:, 0], label='x1(t)', linewidth=2)
plt.plot(time, x_d[0, :], '--', label='x1_d(t)', linewidth=2)
plt.ylabel("x1")
plt.legend()
plt.grid(True)
plt.title("Tracking LQR - Subplots")

# x2 plot
plt.subplot(3, 1, 2)
plt.plot(time, x_simulate[:, 1], label='x2(t)', linewidth=2)
plt.plot(time, x_d[1, :], '--', label='x2_d(t)', linewidth=2)
plt.ylabel("x2")
plt.legend()
plt.grid(True)

# Tracking error plot
plt.subplot(3, 1, 3)
plt.plot(time, x_d[0, :] - x_simulate[:, 0], label='e1(t)', linewidth=2)
plt.plot(time, x_d[1, :] - x_simulate[:, 1], '--', label='e2(t)', linewidth=2)
plt.xlabel("Time [s]")
plt.ylabel("Tracking Error")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

plt.figure(figsize=(6, 6))
plt.plot(x1_noisy, x2_noisy, '--', label='Noisy', alpha=0.3)
plt.plot(x_simulate[:, 0], x_simulate[:, 1], color='purple', label='Predicted trajectory')
plt.xlabel('sol_x1')
plt.ylabel('sol_x2')
plt.title('2D Phase Plot: sol_x1 vs sol_x2')
plt.grid(True)
plt.legend()
plt.axis('equal')  # Keeps aspect ratio square
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import solve_continuous_are

# Define system matrices
A = np.array([[0, 1],
              [-1, 1]])
B = np.array([[0],
              [1]])

Q = np.array([[100, 0],
              [0, 10]])
R = np.array([[1]])

# Solve Continuous Algebraic Riccati Equation
P = solve_continuous_are(A, B, Q, R)
K = np.linalg.inv(R) @ B.T @ P

# Create a reference trajectory
T = 40
dt = 0.2
time = np.arange(0, T, dt)

x_d = np.vstack((x1_noisy, x2_noisy))  # shape: (2, N)

# Compute time derivative of x_d (approximation)
Dx_d = np.gradient(x_d, dt, axis=1)  # shape: (2, N)

# Compute feedforward input: u_d = B^T (Dx_d - A x_d)
u_d = np.zeros(len(time))
for i in range(len(time)):
    xd = x_d[:, i].reshape(-1, 1)
    dxd = Dx_d[:, i].reshape(-1, 1)
    u_d[i] = (B.T @ (dxd - A @ xd)).item()

# Simulate system
x = np.array([[-1.0], [-1.0]])  # initial state
x_simulate = []

for i in range(len(time)):
    xd = x_d[:, i].reshape(-1, 1)
    ud = u_d[i]
    u = ud - K @ (x - xd)
    x_dot = A @ x + B @ u
    x += x_dot * dt
    x_simulate.append(x.flatten())

x_simulate = np.array(x_simulate)

# --- Plotting with 3 subplots ---
plt.figure(figsize=(10, 8))

# x1 plot
plt.subplot(3, 1, 1)
plt.plot(time, x_simulate[:, 0], label='x1(t)', linewidth=2)
plt.plot(time, x_d[0, :], '--', label='x1_d(t)', linewidth=2)
plt.ylabel("x1")
plt.legend()
plt.grid(True)
plt.title("Tracking LQR - Subplots")

# x2 plot
plt.subplot(3, 1, 2)
plt.plot(time, x_simulate[:, 1], label='x2(t)', linewidth=2)
plt.plot(time, x_d[1, :], '--', label='x2_d(t)', linewidth=2)
plt.ylabel("x2")
plt.legend()
plt.grid(True)

# Tracking error plot
plt.subplot(3, 1, 3)
plt.plot(time, x_d[0, :] - x_simulate[:, 0], label='e1(t)', linewidth=2)
plt.plot(time, x_d[1, :] - x_simulate[:, 1], '--', label='e2(t)', linewidth=2)
plt.xlabel("Time [s]")
plt.ylabel("Tracking Error")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

plt.figure(figsize=(6, 6))
plt.plot(x1_noisy, x2_noisy, '--', label='Noisy', alpha=0.3)
plt.plot(x_simulate[:, 0], x_simulate[:, 1], color='purple', label='Predicted trajectory')
plt.xlabel('sol_x1')
plt.ylabel('sol_x2')
plt.title('2D Phase Plot: sol_x1 vs sol_x2')
plt.grid(True)
plt.legend()
plt.axis('equal')  # Keeps aspect ratio square
plt.tight_layout()
plt.show()